staticは初期化が必須　コンストラクタ　staticイニシャライザ等を使う

abstract
具象・抽象メソッドを記述可能　アクセス修飾子に制限はない。子クラスは公開範囲を広めることは可能だか狭めることは不可
抽象クラスを実装した具象クラスは必ず抽象メソッドを実装しなければならない→コンパイルエラー

interface
アクセス修飾子はpublicのみ　final修飾子も不可
変数宣言は自動的にpublic static final　メソッドはpublic abstractが暗黙的に付与
メソッドはpublic final
SE8からデフォルト・staticメソッド(static抽象メソッドは記述不可)の記述可　
デフォルトメソッドはオーバーライド可能(defaultは削除しpublicをつけて再定義)
staticメソッドは具象を記述可　publicのみ(省略すると暗黙的にpublic付与)　implementしなくても他クラスから参照可
インターフェースに記述したstaticメソッドは参照変数.メソッド名での呼び出しは不可　インターフェース名.メソッド名を使用
defaultメソッド(具象メソッド)は public(固定) default 戻り値 メソッド名(引数リスト){} equals hashcode tostringは定義不可
複数のインターフェースを実装した場合、特定のメソッドを呼ぶには、親インターフェース名.super.メソッド名()

型変換
→暗黙的キャスト
byte short int long float double　char int　 演算時左右オペランドのうち下位が上位のdouble float long int に変換される
←明示的キャスト
継承関係のないものをキャストするとコンパイルエラー　継承関係のあるもでキャストできない場合はClassCastException
子クラスを親クラスの型で生成した場合、非staticメソッド以外は全て親クラスのメンバ(staticメソッドも)が呼ばれる
完全一致＞暗黙の型変換＞AutoBoxing>可変長引数

ネストクラス（クラスの中にクラスを記述可)　インタフェースや抽象クラスの定義も可能
staticクラスか非static(インナークラス)の２つ　外側クラス名と重複不可　アクセス修飾子可 abstract final可能
非staticクラスの場合　out.A a = new out().new A();　new out().new A().methodA();　　　　　　new A().methodA()はNG
staticの場合 out.B b = new out.B();    new out.B.methodB() new B().methodB() out.B.methodB() B.method()も可能
outは入れ子の外側クラス
staticクラスは非static・staticメンバを記述可　外側クラスのインスタンス変数(フィールド変数(非static))にアクセス不可
非staticクラスはstaticメンバをもつことができない。外側クラスのインスタンス変数にアクセス可能
同名変数はthisを用いる、外側クラスの同名変数にアクセスするには外側クラス名.this.変数名

ローカルクラス(メソッドの中にクラスを記述、非staticのみ)
アクセス修飾子を使用できない。abstractとfinalは使用可　外側クラスのメンバにアクセス可能
外側クラスの引数・ローカル変数にアクセス可能→アクセスする変数がfinalでないといけない(代入不可)、SE8から自動で付与　フィールド変数はfinal付与は不要

匿名クラス(アクセス修飾子・static・abstract・final使用不可)　代入可能
クラス指定をしないで、クラス定義とインスタンス化を１つの式として定義。サブクラス・インターフェースを実装したクラスになる
外側クラスのメンバにアクセス可能
外側クラスのメソッドの引数・ローカル変数にアクセス可能(ローカル変数・引数は要final)、コンストラクタの定義不可
New　スーパクラス・インターフェース名(){};　無名の実装クラスがインスタンス化される

関数型インタフェース       
UnaryOperator<T> T apply(T t)
Function<T,R> R apply(T t)  
Consumer<T> void accept(T t) 
Predicate<T> boolean test(T t)
Supplier<T> T get()
要件　・単一の抽象メソッド(staticメソッド・defaultメソッドは定義可能)　java.langObjectのpublicメソッドは抽象メソッドとして定義可能
関数型インタフェースとして明示的に宣言する場合は@FunctionInterfaceを付与する abstract classは抽象クラスなので関数型インタフェースではない

Collectionインターフェース 上３つはCollectionがルート　MapはMapがルート　java.utilをインポート
List    データ項目に順序付けしたコレクション　順序づけて管理　重複可能 ArrayList LinkedList Vector E remove(int index)を実装
Set	ユニークな値のコレクション　順不同で管理　重複不可　HashSet TreeSet LinkeHashSet
Queue	FIFO形式のデータを入出力で行うコレクション ArrayDeque　
	削除はremove()しかないので引数を指定するとCollectionインターフェースのメソッドが呼ばれる boolean remove(Object o)
Map	個々のキーに対応する値をマップしたオブジェクト　キーの重複不可、値の重複は可能 HashMap TreeMap LinkedHashMap

ArrayList　挿入削除は線形的に実行、挿入削除の頻度が高くランダムアクセス頻度が低い場合はLinkedListが適している　<T>は参照型ならなんでも良い
	 ランダムアクセス(検索)は高速、挿入と削除は低速　同期性はサポートしていない（スレッドセーフではない)
LinkedList　各要素(ノード)に個々のデータ項目に加えて次のノードに対するポインタが格納　挿入と削除がArrayListより高速　同期性はサポートしていない
Vector	　同期性をサポート　マルチスレッド環境を必要としない場合はArrayListを使用しないとパフォーマンスが低下する
上記のクラスはインデックス順でソートはなし

HashSet　データ項目アクセスはTreeSetより高速、データ項目を順序づけできない　ソートも順序付けも行わない　同期性はサポートしない　重複不可　順不同
TreeSet　SorrtedSetインターフェースの実装クラス。ソートされたデータ項目を得る、HashSetよりも低速　同期性のサポートはしていない　重複不可
	キー元にソートを管理、自然順序付け(文字列は辞書順、数値は昇順)
LinkedHashSet　HashSetと同等の機能に加え、全てのデータ項目に対する二重リンクリストを追加、挿入順で順序づけられ　同期性のサポートはしていない

HashMap　ハッシュテーブルのデータ構造体をベースにした実装。キーと値は順不同で格納　nullをキー・値として使用可能　同期性はサポートしていない
LinkedHashMap 全てのエントリに対する二重リンクリストを保持するという点でHashMapと異なる。キーの挿入順で順序付け　同期性サポートしていない
TreeMap　SortesMapインターフェースを実装したクラス　キーの昇順による順序付けが維持(ソート)　同期性はサポートしていない

ジェネリクス
<>はSE７より型推論により省略可　型パラメータ(<>)で扱えるデータ型は参照型のみ　staticメンバには使用不可　インターフェースで使用可
メソッドにのみ使う場合は アクセス修飾子 <T> 戻り値の型 メソッド名(データ型　引数)　呼び出す際は<>をつけても省略してもどちらでも良い
クラスに使用する場合は class Hoge<T> { private T foo; public T getHoge(return foo;)}
Newする際には1.new Hoge(ture) 2.new Hoge<>(10) 3.new Hoge<String>(“ABC”)どれでもコンパイル可能　ただし1は警告が出る
<T extends Object> TはObjectクラスかサブクラスに対応しなければならない　独自クラスの場合はTを？に変える
<T super タイプ> タプに指定したデータ型やそのスーパクラス(スーパインターフェースも)に対応
<? Extends hoge>の場合、実行するまで?の型がわからないので、add等の何かしらのオブジェクトを格納するコードを記述するとコンパイルエラー
<? Super hoge>の場合は、hogeと同じ型の場合は要素の追加が可能

ソートを利用するには、Comparableを実装しなければならない。java.langパッケージ
実装しないでTreeSetなどのソートするオブジェクトに格納すると実行時例外
Integer,Double,StringなどはComparableを実装しているのでTreeSetオブジェクト等に格納できる
Comparableインターフェースには、compareTo()メソッドのみ宣言されている。自然順序を提供(昇順)
Public int compareTo(T o)　自オブジェクトと引数oに渡されたオブジェクトを比較　結果を整数で返す
比較ルール　　==は０　自＜比較対象→負の数　自＞比較対象→正の数　
Import java.util.*;
Class hoge implements Comparator<String>
Public int compare(String s1, String s2){
	return s1.compareTo(s2) 		自然順序	s1.toLowerCase()で文字を小文字にする
	return s2.compareTo(s1) 		逆になる	s1.toUpperCase()で文字を大文字にする
}

Comparatorインターフェースは比較ルールを独立したクラスとして定義可能 java.utilパッケージ
compare(), equals()メソッドで宣言されている。compare()メソッドをオーバーライドして並び順を決定する実装を行う。equals()の実装は任意
Public int compare(T o1, T o2)  interface Comparator<T>となっているので、比較対象のデータ型をTに指定する必要がある
比較ルールは上記と同じ

配列のソートはArraysクラスを用いる。sortメソッドで自然順序、コンパレータを指定すると独自定義でソート
様々な参照型のオブジェクトを要素に持つ配列をsortメソッドでソートするとClassCastExceptionが発生
配列をリストに変換→asListメソッド。変換されたリストは要素の上書き可、固定サイズのリストのため要素の追加や削除は不可 UnsupportedOperationException発生
			　　
クラス	　　インターフェース	　　重複(項目)	順序付け/ソート	　　　　同期性
ArrayList	List	　　可	　　インデックス順・ソートなし		無	ランダムアクセス(検索)は高速、挿入と削除は低速
LinkedList	Liat	　　可	　　インデックス順・ソートなし		無	挿入と削除がArrayListより高速
Vector		List	　　可	　　インデックス順・ソートなし		有	マルチスレッド環境で使用、シングルではパフォーマンス低下

HashSet		Set	　　不可	　　順序付けなし・ソートなし		無	データ項目アクセスはTreeSetより高速　順不同
LinkedHashSet	Set	　　不可	　　挿入順・ソートなし		無	HashSetと同等の機能に加え、全データ項目に対する二重リンクリストを追加
TreeSet		Set	　　不可	　　自然順または比較ルールでソート	無	SortesMapインターフェースを実装したクラス　要素をソートして管理
PriorityQueue	Queue	　　可	　　自然順または比較ルールでソート	無	優先度ヒープに基づく制限なしの優先度キュー synchronaizedされない

HashMap<K,V>	Map	　　不可	　　順序付けなし・ソートなし		無	キーと値は順不同で格納 nullをキー・値で使用可<K,V>を省略するとobject型
LinkedHashMap	Map	　　不可	　　挿入順・アクセス順・ソートなし	無	全エントリに対する二重リンクリストを保持するという点でHashMapと異なる
Hashtable	Map	　　不可	　　順序付けなし・ソートなし		有	ハッシュ表(キーを値にマップ)を実装　どのオブジェクトでもキー・値に使用可
TreeMap		Map	　　不可	　　自然順または比較ルールでのソート	無	SortesMapインターフェースを実装したクラス　キーをもとにソート

NavigableMapインターフェースはSortedMapインターフェースのサブインターフェース。以下のメソッドを使用可能
K higher[lower]Key(K key) 指定されたキーよりも確実に大きい[小さい]キーの中で最小[最大]のものを返す。
NavigableMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) fromKeyからtoKeyのキー範囲をもつビューを返す。
fromKey[toKey]：返されるマップ内のキーの下端点[上端点] fromInclusive[toInclusive]：返されるビューに下端点[上端点]が含まれるようにする場合にはtrue
ceiling()[floor()]メソッドは指定された要素と等しいかそれより大きい[小さい]要素の中で最小[最大]のものを返す
Mapは指定されたキーまたは値が含まれているか確認する場合は、containsKey(), containsValue()を使用する

Arrays		Java.util(Collectionは実装していない)
順序付けなしは出力した際に挿入した順では出力されない.出力結果は不定。
自然順序(数値は昇順、文字は辞書順)でソートした際に数値と文字列が混ざっていた場合は数値が先にソート
<>を指定しないでリストを作成すると、様々な型のオブジェクトを格納するobject型のリストができる。拡張forでobject型(警告が出る)以外の型を指定するとコンパイルエラー


ラムダ式　<>の型指定をしないとコンパイルエラー
インターフェース		抽象メソッド		概要
Function<T,R>		R apply(T t)		実装するメソッドは、引数としてTを受け取り、結果としてRを返す。
BiFunction<T,U,R>	R apply(T t, U u)	実装するメソッドは、引数としてTとUを受け取り、結果としてRを返す。
UnaryOperator<T>	T apply(T t)		実装するメソッドは、引数としてTを受け取り、結果としてTを返す。Functionを拡張したもの
BinaryOperator<T>	T apply(T t1, T t2)	実装するメソッドは、引数としてTを２つ受け取り、結果としてTを返す。BiFunctionを拡張したもの

Consumer<T>		void accept(T t)	実装するメソッドは、引数としてTを受け取り、結果を返さない。
BiConsumer<T,U>		void accept(T t,U u)	実装するメソッドは、引数としてTとUを受け取り、結果を返さない。

Predicate<T>		boolean test(T t)	実装するメソッドは、引数としてTを受け取り、boolean値を結果として返す。
BiPredicate<T,U>	boolean test(T t,U u)	実装するメソッドは、引数としてTとUを受け取り、boolean値を結果として返す。

Supplier<T>		T get()			実装するメソッドは、何も引数として受け取らず、結果としてTを返す。

ラムダ式の省略記法　右辺
(String str)  →　(str)  → str
インターフェースの宣言時に引数の型は決定しているため、型推論により型を省略できる。
引数が１つの場合は()を省略可能。データ型を明示した場合や引数がない、複数の引数がある場合は省略できない。引数なしは ()-> と記述する。

ラムダ式の省略記法　左辺
{return str.toUpperCase();}　　→   str.UpperCase()
処理が一文の場合は{}の省略が可能。{}を省略した場合、returnの省略が可能。returnを省略した場合、必ず{}も省略しないといけない。

メソッド参照
ラムダ式内で呼び出されるメソッドが一つの場合、SE8ではラムダ式を使用せず記述する方法が導入。これをメソッド参照と呼ぶ
構文	クラス名/インスタンス変数名 :: メソッド名　e.g. Integer::parseInt;

Staticメソッド参照	呼び出すメソッドがstaticメソッドの場合「クラス名::メソッド名」




